#+title: Combining clojure.spec with design recipes
#+author: Diego SÁNCHEZ, Leandro DOCTORS

** Why are we here?
*** to SHARE & to LEARN
**** insights

** Disclaimer
- this tutorial --> +a method+ just our insights
- +dogmas+ (we could be wrong :-)
- tools --> means to an end
- +clojure.spec experts+
  - feel free to improve our code suggestions!

** Systematic Software Development
*** Systematic?
    - carried out using a planned, ordered procedure
    - methodical, regular and orderly
    - (requires building up intermediate products)

*** How systematically do we Approach Programming?
**** "Divide & Conquer!"
***** How about "Conquering"?
****** "Tinker Until It Works"
     #+begin_src clojure
              # 1.
              (while
                (not (it-works?))
                  (hack-hack-hack ...))

              # 2.
              (when (it-works?)
                (do
                  (yell "It works!!")
                  (carry-on ...)))
     #+end_src

     /(How systematic is this? Where are the *intermediate* products?)/
*** /Systematic/ Software Development
***** What?
       - systematic thought, planning, and understanding.
       - from the very beginning, at every stage, and for every step.
***** How?
      - Design Recipes (The Main Scope of this Tutorial)
      - Iterative Refinement (The Secondary Scope of this Tutorial)

**** Design Recipes
***** Why?
      - To provide with *Intermediate products* for beginner-level
      programs.
***** What?
      - A set of step-by-step development guidelines.
      - One common design process.
      - Useful for developing *anything*: from isolated functions to full programs.
***** How?
      1. Problem Analysis --> Data Definitions
      2. Signature, Purpose Statement, Header
      3. Examples
      4. Template
      5. Definition (Code)
      6. Testing

**** Example: Designing a Function in Clojure

     (Example taken from HTDP, Section 3.1)

***** 0. Problem statement

      Compute the area of a square.

***** 1. Problem Analysis --> Data Definitions
        #+begin_src clojure
          ;; We will use natural numbers to represent both the square's side length and area.
        #+end_src

***** 2. Signature, Purpose Statement, Header
        #+begin_src clojure
          ;; Length --> Area
          ;; Compute the area of a square with side len.
          (defn area-of-square
            [len]
            ...)
        #+end_src

***** 3. Examples
        #+begin_src clojure
          ;; given: 2, expect: 4
          ;; given: 7, expect: 49
        #+end_src
***** 4. Template
        #+begin_src clojure
          (defn area-of-square
            [len]
            (... len ...))
        #+end_src
***** 5. Definition (Code)
         #+begin_src clojure
           (defn area-of-square
             [len]
             "compute the area of a square of side `len`."
             (* len len))
         #+end_src
***** 6. Testing
         #+begin_src clojure
           (is (= 4 (area-of-square 2)) "A square of side 2 should have an area of 4.")
           (is (= 49 (area-of-square 7)) "A square of side 7 should have an area of 49.")
         #+end_src

*** Software Specification (clojure.spec)
**** What?
     - How something is "looked at" (modeled).
**** How? (Revisiting our example with clojure.spec)
***** 0. Problem statement (no changes)

      Compute the area of a square.

***** 1. Problem Analysis --> Data Definitions (no changes)
      #+begin_src clojure
      ;; We will use natural numbers to represent both the square's side length and area.
      #+end_src

***** 2. Signature, Purpose Statement, Header (changes significantly!)
      #+begin_src clojure

      (s/def ::lenght
        nat-int?)

      (s/def ::area
        nat-int?)

      ;; Length --> Area
      (s/fdef area-of-square
        :args :len ::lenght
        :ret ::area)

      ;; Compute the area of a square with side len.

      (defn area-of-square
        [len]
        ...)
      #+end_src

***** 3. Examples (no changes)
      #+begin_src clojure
        ;; given: 2, expect: 4
        ;; given: 7, expect: 49
      #+end_src

***** 4. Template (no changes)
      #+begin_src clojure
        (defn area-of-square
          [len]
          (... len ...))
      #+end_src

***** 5. Definition (Code - no changes)
      #+begin_src clojure
        (defn area-of-square
          [len]
          "compute the area of a square of side `len`."
          (* len len))
      #+end_src

***** 6. Testing
      #+begin_src clojure
        (is (= {:total 1, :check-passed 1} (stest/summarize-results (stest/check `area-of-square))))
      #+end_src

** Let's Solve a Problem!
*** Our (Initial) Problem
**** Applying the Recipe
*** What if it changes?
**** Revisiting the Recipe
** Conclusions
** References
** More Information
