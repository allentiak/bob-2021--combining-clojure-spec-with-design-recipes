#+title: Combining clojure.spec with design recipes
#+author: Diego SÁNCHEZ, Leandro DOCTORS

** Why are we here?

- To try gaining some insights from combining an approach (DDD), a
  technique (SSD), and a tooling library (clojure.spec). Nothing more,
  nothing less.

** Disclaimer

- Please avoid taking this tutorial as a method; this is just a suggestion about a possible way of combining two tools.
- We are not dogmatic/orthodox. Plus, we could be wrong :-)
- Avoid focusing on the language or the tools we use: there are other
  combinations to achieve similar results. _(There are clojure.spec
  ports to other languages (Ruby, Python, JavaScript...) with varying
  degree of maturity.)__
- This is *not* a clojure.spec tutorial (we are not clojure.spec
  experts). There may be a few glitches in our code. Please, bear with
  us.

** Introduction
*** Systematic Software Design
**** How to Approach Programming?
***** "Tinker Until It Works"

       1. (While True): Tinker (Hack)
       2. (When it works):
          - "It WORKS!!"
       3. GOTO 1.

       /(Does this sound like something you normally do? How well does it perform?)/

***** /Systematic/ Software Development
****** What?
       - systematic thought, planning, and understanding.
       - from the very beginning, at every stage, and for every step.
****** How?
      - Design Recipes (The Main Scope of this Tutorial)
      - Iterative Refinement (The Secondary Scope of this Tutorial)
**** Design Recipes
***** What?
      - A set of step-by-step development guidelines.
      - One common design process.
      - Useful for developing *anything*: from isolated functions to full programs.
***** Why?
      - To provide with *Intermediate products* for beginner-level
      programs.

***** How?
      1. Problem Analysis --> Data Definitions
      2. Signature, Purpose Statement, Header
      3. Examples
      4. Template
      5. Definition (Code)
      6. Testing

**** Example: Designing a Function in Clojure

     (Example taken from HTDP, Section 3.1)

***** 1. [@0] Problem statement

      Compute the area of a square.

***** 1. Problem Analysis --> Data Definitions
        #+BEGIN_SRC clojure
          ;; We will use natural numbers to represent both the square's side length and area.
        #+END_SRC

***** 2. Signature, Purpose Statement, Header
        #+BEGIN_SRC clojure
          ;; Length --> Area
          ;; Compute the area of a square with side len.
          (defn area-of-square
            [len]
            ...)
        #+END_SRC

***** 3. Examples
        #+BEGIN_SRC clojure
          ;; given: 2, expect: 4
          ;; given: 7, expect: 49
        #+END_SRC
***** 4. Template
        #+BEGIN_SRC clojure
          (defn area-of-square
            [len]
            (... len ...))
        #+END_SRC
***** 5. Definition (Code)
         #+BEGIN_SRC clojure
           (defn area-of-square
             [len]
             "compute the area of a square of side `len`."
             (* len len))
         #+END_SRC
***** 6. Testing
         #+BEGIN_SRC clojure
           (is (= 4 (area-of-square 2)) "A square of side 2 should have an area of 4.")
           (is (= 49 (area-of-square 7)) "A square of side 7 should have an area of 49.")
         #+END_SRC

*** Software Specification (clojure.spec)
**** What?
     - How something is "looked at" (modeled).
**** How? (Revisiting our example with clojure.spec)
***** 1. [@0] Problem statement (no changes)

      Compute the area of a square.

***** 1. Problem Analysis --> Data Definitions (no changes)
      #+BEGIN_SRC clojure
      ;; We will use natural numbers to represent both the square's side length and area.
      #+END_SRC

***** 2. Signature, Purpose Statement, Header (changes significantly!)
      #+BEGIN_SRC clojure

      (s/def ::lenght
        nat-int?)

      (s/def ::area
        nat-int?)

      ;; Length --> Area
      (s/fdef area-of-square
        :args :len ::lenght
        :ret ::area)

      ;; Compute the area of a square with side len.

      (defn area-of-square
        [len]
        ...)
      #+END_SRC

***** 3. Examples (no changes)
      #+BEGIN_SRC clojure
        ;; given: 2, expect: 4
        ;; given: 7, expect: 49
      #+END_SRC

***** 4. Template (no changes)
      #+BEGIN_SRC clojure
        (defn area-of-square
          [len]
          (... len ...))
      #+END_SRC

***** 5. Definition (Code - no changes)
      #+BEGIN_SRC clojure
        (defn area-of-square
          [len]
          "compute the area of a square of side `len`."
          (* len len))
      #+END_SRC

***** 6. Testing
      #+BEGIN_SRC clojure
        (is (= {:total 1, :check-passed 1} (stest/summarize-results (stest/check `area-of-square))))
      #+END_SRC

*** Domain-Driven Development (Domain Modeling made Functional)
**** Guidelines (DMMF)
     [Problem Space]
     0. Involves All Stakeholders (Domain Experts, Dev. Team, Other
   Stakeholders) ...and the Code.

     1. Focus on Data /Transformations/, rather than on Data /Structures/.
   ==> Core Domain /(Provides business advantage(s)./Brings in the
   money.)/ /(Not Core? Supportive.)/

     2. Partition the Problem => (smaller) Subdomains

     [Solution Space]

     3. Model Subdomains as Bounded Contexts /(not necessarily a 1-to-1
   correspondence)/

     4. Model the Interactions across Bounded Contexts

     5. Develop an Ubiquitous Language (can have dialects across Contexts)
   /(A *Globally** Shared, Available, Live, and Context-Dependant Mental
   Model.)/

** Let's Solve a Problem!
*** Problem Statement
*** What have we learned so far?
** What if it changes?
*** A New Requirement!
*** What have we learned today?
** Conclusions
** References
** More Information
